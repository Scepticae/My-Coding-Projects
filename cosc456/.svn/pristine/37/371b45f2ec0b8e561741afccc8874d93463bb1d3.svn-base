/* utils.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <GL/gl.h>
#include <GL/glut.h>
#include "utils.h"
#include "jmesh.h"

float angle = 0.0;
int ms = 25;
static graphics_state * current_gs;

void print_howto(void){
  printf("So far it does nothing - you output howto here\n");
  printf("Up Arrow:     Rotate Up\n");
  printf("Down Arrow:   Rotate Down\n");
  printf("Left Arrow:   Rotate Left\n");
  printf("Right Arrow:  Rotate Right\n");
  printf("Page UP:      Zoom In\n");
  printf("Page Down:    Zoom Out\n");
  printf("Home:         Reset View\n");
  printf("Insert:       Exit Program\n");
}

void 
set_gs(graphics_state * gs){
  current_gs = gs;
}

void 
init(graphics_state * gs){
  current_gs = gs;
  glClearColor(1.0f, 0.51f, 0.0f, 1.0f); //Clear Background Color to Orange
	glClearDepth(1.0f); //Set Background Depth to Farthest
  glEnable(GL_DEPTH_TEST); //Enable Depth Testing for Z-Culling
  glDepthFunc(GL_LEQUAL); //Set the Type of Depth Test
  glShadeModel(GL_SMOOTH); //Enable Smooth Shading
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  // Nice perspective corrections
}

void 
display(void){
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear color and depth buffers
  glMatrixMode(GL_MODELVIEW);     // To operate on model-view matrix
	gluLookAt(0.0,0.0,1.0, 0.0, 0.0, -100.0, 0.0, 1.0, 0.0);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	
	//Normalize the vertices
	norm_vert(current_gs->jm);
	
	//Draw the System
	drawSystem();
	
  glutSwapBuffers();
}

void drawObject(float r, float g, float b){
	int i;
	glBegin(GL_TRIANGLES);
		glColor3f(r, g, b);
		for(i=0; i < current_gs->jm->ntri; i++){
			glVertex3fv(current_gs->jm->vertices[current_gs->jm->triangles[i][0]]);
			glVertex3fv(current_gs->jm->vertices[current_gs->jm->triangles[i][1]]);
			glVertex3fv(current_gs->jm->vertices[current_gs->jm->triangles[i][2]]);
		}
	glEnd();
}

//Draws the Solar System for a Sun and 4 Planets
void drawSystem(){
	int i;
	float j = 0.0f; 
	float r = 1.0, g = 0.5, b = 0.0; //Set Sun's Color Initially
	float s = 0.1; //Set Sun's Scale Initially
	
	//Draw the Planets
	for(i = 0; i < 5; i++){
		//Set the Color for Each Planet
		if(i == 1){r=1.0; g=0.0; b=0.0;}
		else if(i == 2){r=0.0; g=1.0; b=0.0;}
		else if(i == 3){r=0.0; g=0.0; b=1.0;}
		else if(i == 4){r=1.0; g=1.0; b=1.0;}
		
		//Update the Scale and X Position
		if(i > 0){s = 0.05;}
		
		//Set Planets Location, Scale and Rotation
		glPushMatrix();
		glLoadIdentity();
		glTranslatef(j, 0.0f, -30.0f); 
		glRotatef(30.0f, 0.0f, 1.0f, 0.0f);
		glRotatef(15.0f, 1.0f, 0.0f, 0.0f);
		glScalef(s, s, s);
		drawObject(r, g, b);
		glPopMatrix();
		
		//Update the X Value
		j += 2.5f;
	}
}

//Updates the Angle and Redraws the System
void update(int val){
	//Update the angle
	angle += 1.0;
	 
	//Update the Timer and Redraw the Display
  glutPostRedisplay();
  glutTimerFunc(ms, update, 0);
}

void 
reshape(int w, int h){
	// Compute aspect ratio of the new window
   if (h == 0) h = 1; //Prevent Division by Zero
   GLfloat aspect = (GLfloat)w / (GLfloat)h;
 
   // Set the viewport to cover the new window
   glViewport(0, 0, w, h);
 
   // Set the aspect ratio of the clipping volume to match the viewport
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
	 
   // Enable perspective projection with fovy, aspect, zNear and zFar
   gluPerspective(45.0f, aspect, 0.1f, 100.0f);
	 glMatrixMode(GL_MODELVIEW);
	 glLoadIdentity();
	 glTranslatef(0.0, 0.0, 0.0);
}

void 
mouse_handler(int button, int button_state, int x, int y){
  
}

void 
trackMotion(int x, int y) {

}

void 
keys(unsigned char c, int x, int y) {
  switch(c) {
		case 'q': case 'Q' :
			exit( EXIT_SUCCESS );
			break;
	}
}

void norm_vert(jmesh *jm){
	int i;
	float tmp;
	
	for(i=0; i < jm->nvert; i++){
		//if(jm->max_x > 1.0 || jm->max_y > 1.0 || jm->max_z > 1.0 || jm->min_x < -1.0 || jm->min_y < -1.0 || jm->min_z < -1.0){
		  //tmp = ((((jm->vertices[i][0] - jm->min_x) * 2.0) / (jm->max_x - jm->min_x)) - 1.0);
			tmp = (((jm->vertices[i][0] - jm->min_x) * 2.0) / (jm->max_x - jm->min_x) - 1.0) ;
			jm->vertices[i][0] = tmp;
			//tmp = ((((jm->vertices[i][1] - jm->min_y) * 2.0) / (jm->max_y - jm->min_y)) - 1.0);
			//tmp = jm->vertices[i][1] / mag*0.2;
			tmp = (((jm->vertices[i][1] - jm->min_y) * 2.0) / (jm->max_y - jm->min_y) - 1.0) ;
			jm->vertices[i][1] = tmp;
			//tmp = ((((jm->vertices[i][2] - jm->min_z) * 2.0) / (jm->max_z - jm->min_z)) - 1.0);
			//tmp = jm->vertices[i][2] / mag*0.2;
			tmp = (((jm->vertices[i][2] - jm->min_z) * 2.0) / (jm->max_z - jm->min_z) - 1.0) ;
			jm->vertices[i][2] = tmp;
		//}
	}
}
